var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internal-Documentation","page":"Internals","title":"Internal Documentation","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for the internals of MNN.jl. These are subject to change.","category":"page"},{"location":"lib/internals/#Contents","page":"Internals","title":"Contents","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]\nDepth = 2:2","category":"page"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/internals/#Public-Interface","page":"Internals","title":"Public Interface","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [MNN]\nPublic = false","category":"page"},{"location":"lib/internals/#MNN.Neuron","page":"Internals","title":"MNN.Neuron","text":"struct Neuron\n\nRepresents a node between springs. Position and velocity are stored in the MNN.Network.\n\nFields\n\nmovable::Bool: Is the neuron movable (not fixed to wall)?\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#MNN.Simulation","page":"Internals","title":"MNN.Simulation","text":"abstract type Simulation\n\nInherit from this type to implement your own simulation method. Your Simulation type should have a field modifier::Function (see )\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#MNN.Spring","page":"Internals","title":"MNN.Spring","text":"struct Spring\n\nRepresents an edge between neurons.\n\nFields\n\nspring_constant::Float64: The spring constant.\nlength::Float64: The length of the spring at rest; this is constant and can't be changed after creation of the object.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#MNN.calc_ydist-Tuple{Any}","page":"Internals","title":"MNN.calc_ydist","text":"calc_ydist(xdist)\n\nCalculate necessary distance on y axis to create an equilateral triangle with given distance between columns on x axis.\n\n\n\n\n\n","category":"method"},{"location":"man/customize-simulation/#Adding-Your-Own-Simulation","page":"Adding Your Own Simulation","title":"Adding Your Own Simulation","text":"","category":"section"},{"location":"man/guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"man/guide/#Installation-and-Setup","page":"Guide","title":"Installation & Setup","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"As it is still in development, this package is not available in the General Registry yet. You can still install the latest version using the Julia package manager with","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"julia> # type ] to open package manager\n\npkg> add https://github.com/Alexander-Reimer/Simulation-of-MNNs","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"This should install the MNN package and all dependencies automatically.","category":"page"},{"location":"man/guide/#NixOS","page":"Guide","title":"NixOS","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"When using NixOS, activating the development shell is necessary to make GLMakie and consequently the visualization of MNNs / graphs / ... possible:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"cd /path/to/this/project\nnix-shell .","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"This will load the configuration in default.nix.","category":"page"},{"location":"man/guide/#Usage-Example-–-Simulating-and-Optimizing-a-Deformation-Behaviour","page":"Guide","title":"Usage Example – Simulating & Optimizing a Deformation Behaviour","text":"","category":"section"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Load MNN library:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"using MNN","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Create a new MNN:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"using Random\nRandom.seed!(1)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"net = Network(5, 4) # 5 columns, 4 rows","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Create a deformation behaviour using a GUI:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"b = get_user_behaviour(net)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"(Image: Screenshot of the GUI showing a MNN)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Left-click a neuron in first or last column and then release the mouse button to select it\nIf you move your mouse, you should see a blue (force vector applied to neuron) or red (goal position) arrow. Click again to save / select the current arrow for this neuron.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Or create a random deformation behaviour:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"b = create_deformation_behaviours(net, 1)[1]","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Show MNN and created behaviour:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"vis = Visualizer(net, behaviour=b)\nMNN.GLMakie.save(\"usageA_Visualization.svg\", vis.fig, backend=MNN.CairoMakie) # hide","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"(Image: Visualization of the MNN with the behaviours.)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Simulate the behaviour:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Keep the window of the last step open, then execute","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"visB = vis;\nvis = nothing;","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"simulate!(net, SecondOrderDiff(500), b, vis=vis)\nreset!(net, vis = visB); # hide\nMNN.GLMakie.record(visB.fig, \"usageA_simulationBefore.mp4\", 1:70) do i # hide\n    simulate!(net, MNN.SecondOrderDiff(3), b, vis = visB) # hide\nend; # hide","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"(Image: Video of the MNN being simulated with forces given in behaviour being applied. The end positions don't fit to the given goals.)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"You should now see the mass points (\"neurons\") of the network settling into new stable positions according to the random spring constants set when you created the MNN and the forces randomly generated or set by you. This may take a while the first time because of precompilation, but should then be very fast in the same Julia session.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"It should also be obvious that the neurons in the last column are far away from the set goal (except if you got really, really, really lucky).","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Creating a trainer:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"To optimize the spring constants, we need a Trainer object:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"t = Trainer([b], SecondOrderDiff(500), PPS())","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Training:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Now we train for 500 Epochs:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"train!(net, 500, t)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Ideally, the base loss (the best loss so far) will decrease significantly.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"If it hasn't, try executing the previous command again to train the MNN more.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"If that still doesn't get satisfactory results, then maybe the goals and/or forces you set using the GUI were too large.","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Testing:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"Now check if the MNN fits the given shape morphing behaviour better:","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"vis = Visualizer(net, behaviour=b); # update visualization of spring constants\nvisB = vis # hide\nvis = nothing # hide\nreset!(net, vis=vis) # reset neuron positions\nsimulate!(net, SecondOrderDiff(500), b, vis=vis)\nreset!(net, vis = visB); # hide\nMNN.GLMakie.record(visB.fig, \"usageA_simulationAfter.mp4\", 1:70) do i # hide\n    simulate!(net, MNN.SecondOrderDiff(3), b, vis = visB) # hide\nend; # hide","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"(Image: Video of the MNN being simulated with forces given in behaviour being applied. The end positions now fit much better to the given goals.)","category":"page"},{"location":"man/guide/","page":"Guide","title":"Guide","text":"As you can (hopefully) see, the end positions of the neurons now fit much better. The values of the spring constants probably also changed significantly. You can see this by looking at the colors of the springs (lines between neurons): Red means positive spring constant and blue means negative constant.","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public API","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Documentation for MNN.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"lib/public/#Contents","page":"Public API","title":"Contents","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Pages = [\"public.md\"]\nDepth = 2:2","category":"page"},{"location":"lib/public/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public API","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Modules = [MNN]\nPrivate = false","category":"page"},{"location":"lib/public/#MNN.Deformation","page":"Public API","title":"MNN.Deformation","text":"mutable struct Deformation <: Behaviour\n\nA deformation behaviour for the MNN to learn.\n\nFields\n\ngoals: A dictionary with the goal positions of the neurons. Each key is a neuron index\n\nwith the value being a vector of the goal coordinates ([x, y]). If relative is true,  then the coordinates will be interpreted as relative to the initial coordinates of the  neurons, meaning as vector from the initial position, otherwise they will be interpreted as  absolute coordinates.\n\nrelative: A boolean indicating whether the goal coordinates are relative or absolute.\nmodifiers: A dictionary with the modifiers for the neurons. Each key is a neuron index\n\nwith the value being a vector of the accelerations ([x, y]) which will be added to the  velocity of the respective neuron continuously during the simulation,\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#MNN.Euler","page":"Public API","title":"MNN.Euler","text":"mutable struct Euler <: Simulation\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#MNN.Euler-Tuple{Number}","page":"Public API","title":"MNN.Euler","text":"Euler(time::Number)\n\nCreate an Euler simulation with given time.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#MNN.Network","page":"Public API","title":"MNN.Network","text":"mutable struct Network\n\nRepresents a MNN.\n\nFields\n\ngraph::MetaGraphsNext.MetaGraph: The graph representing the MNN (see MetaGraph.jl docs for more details). The edges are of type MNN.Spring, the node of type MNN.Neuron.\nrows::Int: How many rows fixed columns have.\nrow_counts::Array{Int,1}: How many neurons are in each column. Access with column index (e.g. row_counts[1] == 5 –> the first column has 5 rows).\ncol_fixed::Array{Bool,1}: Whether the top and bottom neuron of a column are fixed (not movable). Access with column index like above, e.g. network.col_fixed[1] == true –> the first column is fixed, so get_neuron(network, 1, 1).movable == false.\ncolumns::Int: How many columns the MNN has.\nneuron_count::Int: How many neurons the MNN has.\nxdist::Float64: How far apart the columns are initially on the x axis.\nydist::Float64: How far apart the neurons of a column are initially on the y axis.\nstart_positions::Dict{Int,Vector{Number}}: The initial positions of the neurons, accessed throught the neuron index. Example: network.start_positions[get_neuron_index(network, 1, 1)] should always return [0, 0].\npositions::Array{Float64,2}: The current positions of the neurons. First index represents the space components, second one the neuron. So network.positions[:, 1] for position of first neuron, network.positions[2, 1] for just the y component of the first neuron.\nvelocities::Array{Float64,2}: The current velocities of the neurons. Same indexing as positions.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#MNN.SecondOrderDiff","page":"Public API","title":"MNN.SecondOrderDiff","text":"mutable struct SecondOrderDiff <: Simulation\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#MNN.get_user_behaviour-Tuple{Network}","page":"Public API","title":"MNN.get_user_behaviour","text":"get_user_behaviour(network::Network)\n\nGet deformation behaviour using GUI. Left click on a neuron (first or last column) to select it, then release left mouse button and move mouse pointer to move the other end of the goal / force vector. Click left mouse button again to confirm.\n\nIf you have set all force and goal vectors you want, press space to finish. The function will then return a MNN.Deformation object.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#MNN.simulate!-Tuple{Network, MNN.Simulation, MNN.Behaviour}","page":"Public API","title":"MNN.simulate!","text":"simulate!(network::Network, sim::Simulation, behaviour::Behaviour; vis::Union{Visualizer,Nothing}=nothing)\n\nSimulate network with given behaviour. Simulation method is determined by type of sim; currently MNN.SecondOrderDiff and MNN.Euler are implemented.\n\nTo implement your own, you need to define a struct that is a subtype of MNN.Simulation and has the field modifier::Function. Then overload the function MNN.simulate!(network::Network, sim::YourType; vis::Union{Visualizer, Nothing} = nothing).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MNN","category":"page"},{"location":"#MNN.jl","page":"Home","title":"MNN.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nPlease note that this project is still in development. It is already usable, but there will probably be frequent breaking changes in the future as we expand and refactor this library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We (Matteo Friedrich and Alexander Reimer) are currently participating in Jugend forscht 2024 (a German youth science competition). For our project, we needed a library capable of simulating, optimizing and visualizing Mechanical Neural Networks (MNNs). Since we couldn't find one, we decided to develop and publish our own: MNN.jl. The source code is available in our GitHub repository.","category":"page"},{"location":"#What-Are-MNNs?","page":"Home","title":"What Are MNNs?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mechanical Neural Networks (MNNs for short) are networks made of mass points connected by springs with variable spring constants. With a large enough network, a MNN can be trained to exhibit almost any behaviour desired by setting the spring constants appropiately. Importantly, they can be trained with multiple behaviours at once to exhibit different reactions depending on the \"inputs\" (forces acting on them). This makes them potentially useful for airplane wings which adjust theirs shape depending on the force and angle of the wind, body armor absorbing shock, better seat cushions or better wind turbine blades. Besides these examples of shape morphing behaviours, adjusting the resonance curves of MNNs is also possible and opens the door for applications like earthquake safe buildings, better music instruments, objects like walls capable of strengthening or weakening acoustic signals at will.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We based our research and knowledge of MNNs on the 2022 paper \"Mechanical neural networks: Architected materials that learn behaviors\" by Ryan H. Lee, Erwin A. B. Mulder and Jonathan B. Hopkins. They are, as far as we are aware, the first to describe such Mechanical Neural Networks.","category":"page"},{"location":"#Features-of-this-library","page":"Home","title":"Features of this library","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulation of MNNs\nEvaluating the performance of MNNs for shape morphing and resonance behaviour with MSE\nOptimizing the spring constants with Partial Pattern Search or an evolutionary algorithm","category":"page"},{"location":"#Our-Research","page":"Home","title":"Our Research","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For detailed papers (only in German), see the paper branch on GitHub. The most recent one available is from our participation at the state-level competition in Lower Saxony: paper.pdf","category":"page"},{"location":"#Summary","page":"Home","title":"Summary","text":"","category":"section"},{"location":"#What-We-Did","page":"Home","title":"What We Did","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Both confirmed existing results and how representative our simulation is by analysing the correlation between different hyperparameters and training success, which mostly fit the existing research by Lee et al.\nUnlike Lee et al., we used the optimization algorithms applicable to physical MNNs like Partial Pattern Search and/or evolutionary algorithms instead of a gradient descent based approach\nSuccessfully optimized the resonance curve of MNNs; we believe to be the first to do this, as we couldn't find anything else available online","category":"page"},{"location":"#What-We-Didn't-Do-(Yet)","page":"Home","title":"What We Didn't Do (Yet)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Build our own MNN mechanically\nBuild a ressource intensive, physically accurate simulation\nthe goal is to provide starting points for the optimization of real MNNs and figure out the effects of parameters & different optimization algorithms\nspecifically, we haven't (yet) incorparated checking spring and neuron position limits, meaning that using very large input forces / goal position vectors can result in mass points and springs phasing through each other","category":"page"},{"location":"#Project-Summary-(German)","page":"Home","title":"Project Summary (German)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Wir haben uns mit dem neuen Bereich der mechanical neural networks (MNNs) beschäftigt - programmierbare Materialien, die aus mit Federn verbundenen Massenpunkten bestehen. Ihnen können durch Anpassung der Federhärten verschiedene Verhaltensweisen gleichzeitig antrainiert werden, was viele Anwendungsmöglichkeiten eröffnet, wie z.B. Flugzeugflügel, deren Form sich optimal an Windgeschwindigkeit und -richtung anpasst. In unserem Projekt haben wir die Trainingsverfahren und den Einfluss verschiedener Parameter analysiert und dafür in einer eigenen Softwarebibliothek die Simulation, Optimierung, Bewertung und Visualisierung von MNNs umgesetzt. Außerdem haben wir als Erste erfolgreich die Resonanzkurven von MNNs optimiert, was auch den Einsatz für z.B. erdbebensichere Strukturen ermöglicht. Die von uns erkannten Einflüsse von Parametern decken sich, wo vorhanden, mit der bisherigen Forschung.","category":"page"}]
}
