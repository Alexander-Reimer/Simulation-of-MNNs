var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = MNN","category":"page"},{"location":"#MNN","page":"Home","title":"MNN","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MNN.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This project was created for Jugend Forscht 2024 (a German STEM competition).","category":"page"},{"location":"#Project-Summary-(German)","page":"Home","title":"Project Summary (German)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Wir wollen uns mit dem neuen, noch vergleichsweise wenig erforschten Bereich der mechanical neural networks, kurz MNNs, beschäftigen. MNNs sind programmierbare Materialien, welchen verschiedene Verhaltensweisen, wie zum Beispiel ein bestimmtes Verformungsverhalten, antrainiert werden können. Sie bestehen aus Massepunkten (genannt Neuronen), welche durch Federn miteinander verbunden werden. Ihr Verhalten ergibt sich durch die Steifheiten der Federn. Die grundlegende Annahme von MNNs ist, dass diese Federkonstanten in zukünftigen Materialien einzeln angepasst werden können. In Analogie zu künstlichen neuronalen Netzwerken wäre es dann prinzipiell möglich, durch eine geeignet gewählte Konfiguration an Federkonstanten verschiedene Verhaltensweisen auf externe Kräfte anzutrainieren. Während sich die bisherige Forschung auf die technische, physische Implementation dieser Netzwerke fokussiert hat, wollen wir das Trainingsverfahren optimieren. Dazu haben wir bereits eine Simulation eines MNNs umgesetzt, die bisher verwendeten Algorithmen (evolutionäres Lernen und Pattern Search) selbst implementiert, sowie mit neuen Parametern ausprobiert und verglichen. Dafür haben wir uns jedoch auf die Anwendung dieser Algorithmen in Simulationsrechnungen beschränkt. Die Ergebnisse sollten dennoch einen guten Startpunkt für reale MNNs bieten. Der von uns entwickelte Code ist die erste öffentlich verfügbare Implementation eines MNNs. Unsere Ergebnisse zeigen, dass MNNs mehrere komplexe Verhaltensweisen lernen können. Diese intelligenten Materialien eröffnen vielfältige zukünftige technologische Anwendungsmöglichkeiten.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Open the Julia REPL, then","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> # type ] to open package manager\n\npkg> add https://github.com/Alexander-Reimer/Simulation-of-MNNs","category":"page"},{"location":"","page":"Home","title":"Home","text":"This should install the MNN package and all dependencies automatically.","category":"page"},{"location":"#NixOS","page":"Home","title":"NixOS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When using NixOS, activating the development shell is necessary to make GLMakie work:","category":"page"},{"location":"","page":"Home","title":"Home","text":"cd /path/to/this/project\nnix-shell .","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use MNN.jl in you project, you should first import it with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using MNN","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can then create your first MNN (see MNN.get_user_behaviour for instructions on how to use the GUI):","category":"page"},{"location":"","page":"Home","title":"Home","text":"# create a MNN  with 5 columns and 4 rows\nnet = Network(5, 4) \n# show the network\nvis = Visualizer(net)\n# create a behaviour to simulate using a GUI\nb = get_user_behaviour(network::Network)\n# simulate network with forces determined by b applied for 500 time steps\nsimulate!(net, Diff(500), b, vis = vis)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [MNN]","category":"page"},{"location":"#MNN.Network","page":"Home","title":"MNN.Network","text":"mutable struct Network\n\nRepresents a MNN.\n\nFields\n\ngraph::MetaGraphsNext.MetaGraph: The graph representing the MNN (see MetaGraph.jl docs for more details). The edges are of type MNN.Spring, the node of type MNN.Neuron.\nrows::Int: How many rows fixed columns have.\nrow_counts::Array{Int,1}: How many neurons are in each column. Access with column index (e.g. row_counts[1] == 5 –> the first column has 5 rows).\ncol_fixed::Array{Bool,1}: Whether the top and bottom neuron of a column are fixed (not movable). Access with column index like above, e.g. network.col_fixed[1] == true –> the first column is fixed, so get_neuron(network, 1, 1).movable == false.\ncolumns::Int: How many columns the MNN has.\nneuron_count::Int: How many neurons the MNN has.\nxdist::Float64: How far apart the columns are initially on the x axis.\nydist::Float64: How far apart the neurons of a column are initially on the y axis.\nstart_positions::Dict{Int,Vector{Number}}: The initial positions of the neurons, accessed throught the neuron index. Example: network.start_positions[get_neuron_index(network, 1, 1)] should always return [0, 0].\npositions::Array{Float64,2}: The current positions of the neurons. First index represents the space components, second one the neuron. So network.positions[:, 1] for position of first neuron, network.positions[2, 1] for just the y component of the first neuron.\nvelocities::Array{Float64,2}: The current velocities of the neurons. Same indexing as positions.\n\n\n\n\n\n","category":"type"},{"location":"#MNN.Neuron","page":"Home","title":"MNN.Neuron","text":"struct Neuron\n\nRepresents a node between springs. Position and velocity are stored in the MNN.Network.\n\nFields\n\nmovable::Bool: Is the neuron movable (not fixed to wall)?\n\n\n\n\n\n","category":"type"},{"location":"#MNN.Spring","page":"Home","title":"MNN.Spring","text":"struct Spring\n\nRepresents an edge between neurons.\n\nFields\n\nspring_constant::Float64: The spring constant.\nlength::Float64: The length of the spring at rest; this is constant and can't be changed after creation of the object.\n\n\n\n\n\n","category":"type"},{"location":"#MNN.calc_ydist-Tuple{Any}","page":"Home","title":"MNN.calc_ydist","text":"calc_ydist(xdist)\n\nCalculate necessary distance on y axis to create an equilateral triangle with given distance between columns on x axis.\n\n\n\n\n\n","category":"method"},{"location":"#MNN.get_user_behaviour-Tuple{Network}","page":"Home","title":"MNN.get_user_behaviour","text":"get_user_behaviour(network::Network)\n\nGet user input for behaviour.\n\n\n\n\n\n","category":"method"},{"location":"#MNN.simulate!-Tuple{Network, MNN.Simulation, MNN.Behaviour}","page":"Home","title":"MNN.simulate!","text":"simulate!(\nnetwork::Network,\nsim::Simulation,\nbehaviour::Behaviour;\nvis::Union{Visualizer,Nothing}=nothing,\n\n)\n\nTBW\n\n\n\n\n\n","category":"method"}]
}
